<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Glitch Image Animation</title>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background-color: #000;
    }

    canvas {
      max-width: 300px;
      max-height: 300px;
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
      border-radius: 10px;
    }
  </style>
</head>

<body>
  <canvas id="glitchCanvas"></canvas>

  <script>
    class AdvancedGlitchAnimation {
      constructor(imageUrl, canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.image = new Image();
        this.image.src = imageUrl;

        this.glitchChannels = ['red', 'green', 'blue'];
        this.glitchEffects = ['shift', 'slice', 'distort'];

        // Add glitch intensity control
        this.glitchIntensity = 0.5; // Default intensity
        this.glitchFrequency = 0.1; // How often glitches occur

        this.image.onload = () => {
          this.canvas.width = this.image.width;
          this.canvas.height = this.image.height;
          this.startAnimation();
        };
      }

      startAnimation() {
        this.animate();
      }

      randomGlitch() {
        const ctx = this.ctx;
        const canvas = this.canvas;
        const img = this.image;

        // Clear previous frame
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0);

        // Use class-level intensity and frequency
        if (Math.random() < this.glitchFrequency) {
          // Dynamically adjust intensity based on glitchIntensity
          const intensity = this.glitchIntensity;

          // Multiple glitch techniques
          const effect = this.glitchEffects[Math.floor(Math.random() * this.glitchEffects.length)];

          switch (effect) {
            case 'shift':
              this.colorShiftGlitch(intensity);
              break;
            case 'slice':
              this.imageSliceGlitch(intensity);
              break;
            case 'distort':
              this.pixelDistortGlitch(intensity);
              break;
          }
        } else {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          this.ctx.drawImage(this.image, 0, 0);
        }
      }

      colorShiftGlitch(intensity) {
        const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
        const data = imageData.data;

        // Scale offset range based on intensity
        const maxOffset = Math.floor(100 * intensity);

        for (let i = 0; i < data.length; i += 4) {
          if (Math.random() < intensity) {
            const channel = this.glitchChannels[Math.floor(Math.random() * this.glitchChannels.length)];
            const offset = Math.floor(Math.random() * maxOffset * 2 - maxOffset);

            switch (channel) {
              case 'red':
                data[i] = Math.max(0, Math.min(255, data[i] + offset));
                break;
              case 'green':
                data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + offset));
                break;
              case 'blue':
                data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + offset));
                break;
            }
          }
        }

        this.ctx.putImageData(imageData, 0, 0);
      }

      imageSliceGlitch(intensity) {
        // Scale slice count and offset based on intensity
        const sliceCount = Math.floor(Math.random() * (10 * intensity) + 3);
        const maxOffset = Math.floor(50 * intensity);

        for (let i = 0; i < sliceCount; i++) {
          // Randomly choose between horizontal and vertical slices
          const isVertical = Math.random() < 0.1;

          if (isVertical) {
            // Vertical slice
            const sliceWidth = Math.floor(Math.random() * this.canvas.width * intensity / 4);
            const sourceX = Math.floor(Math.random() * this.canvas.width);
            const destX = Math.floor(Math.random() * this.canvas.width);
            const offsetY = Math.floor(Math.random() * maxOffset * 2 - maxOffset);

            this.ctx.drawImage(
              this.canvas,
              sourceX, 0, sliceWidth, this.canvas.height,
              destX, offsetY, sliceWidth, this.canvas.height
            );
          } else {
            // Horizontal slice (original implementation)
            const sliceHeight = Math.floor(Math.random() * this.canvas.height * intensity / 4);
            const sourceY = Math.floor(Math.random() * this.canvas.height);
            const destY = Math.floor(Math.random() * this.canvas.height);
            const offsetX = Math.floor(Math.random() * maxOffset * 2 - maxOffset);

            this.ctx.drawImage(
              this.canvas,
              0, sourceY, this.canvas.width, sliceHeight,
              offsetX, destY, this.canvas.width, sliceHeight
            );
          }
        }
      }

      pixelDistortGlitch(intensity) {
        const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
        const data = imageData.data;

        // Scale distortion range based on intensity
        const maxDistort = Math.floor(20 * intensity);

        for (let i = 0; i < data.length; i += 4) {
          if (Math.random() < intensity) {
            const distortX = Math.floor(Math.random() * maxDistort * 2 - maxDistort);
            const distortY = Math.floor(Math.random() * maxDistort * 2 - maxDistort);

            const targetIndex = i + (distortY * this.canvas.width * 4) + (distortX * 4);

            if (targetIndex >= 0 && targetIndex < data.length) {
              data[i] = data[targetIndex];
              data[i + 1] = data[targetIndex + 1];
              data[i + 2] = data[targetIndex + 2];
            }
          }
        }

        this.ctx.putImageData(imageData, 0, 0);
      }

      animate() {
        this.randomGlitch();
        requestAnimationFrame(() => this.animate());
      }
    }

    // Initialize glitch animation on page load
    document.addEventListener('DOMContentLoaded', () => {
      const glitchAnimation = new AdvancedGlitchAnimation('images/kirupa.png', 'glitchCanvas');
    });
  </script>
</body>

</html>
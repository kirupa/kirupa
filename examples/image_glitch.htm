<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Glitch Image Animation</title>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background-color: #000;
    }

    canvas {
      max-width: 300px;
      max-height: 300px;
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
      border-radius: 10px;
    }
  </style>
</head>

<body>
  <canvas id="glitchCanvas"></canvas>

  <script>
    class GlitchImageAnimation {
      constructor(imageUrl, canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.image = new Image();
        this.image.src = imageUrl;

        this.imageLoaded = false;
        this.image.onload = () => {
          this.canvas.width = this.image.width;
          this.canvas.height = this.image.height;
          this.imageLoaded = true;
          this.startAnimation();
        };

        // Glitch effect parameters
        this.glitchIntensity = 100;
        this.glitchFrequency = 0.1;
      }

      startAnimation() {
        if (!this.imageLoaded) return;
        this.animate();
      }

      createGlitchEffect() {
        const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
        const data = imageData.data;

        for (let i = 0; i < data.length; i += 4) {
          if (Math.random() < this.glitchFrequency) {
            // More dramatic color channel shift
            const shift = Math.random() * this.glitchIntensity * 500;
            const channel = Math.floor(Math.random() * 3);

            switch (channel) {
              case 0: // Red channel
                data[i] = Math.min(255, Math.max(0, data[i] + shift - 250));
                break;
              case 1: // Green channel
                data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + shift - 250));
                break;
              case 2: // Blue channel
                data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + shift - 250));
                break;
            }
          }

          // Larger and more frequent pixel displacement
          if (Math.random() < this.glitchFrequency) {
            const offsetX = Math.floor(Math.random() * this.canvas.width);
            const offsetY = Math.floor(Math.random() * this.canvas.height);

            const targetIndex = i + (offsetY * this.canvas.width * 4) + (offsetX * 4);
            if (targetIndex >= 0 && targetIndex < data.length) {
              // More dramatic pixel swap
              data[i] = data[targetIndex];
              data[i + 1] = data[targetIndex + 1];
              data[i + 2] = data[targetIndex + 2];
            }
          }
        }

        this.ctx.putImageData(imageData, 0, 0);
      }

      animate() {
        // Clear canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw original image
        this.ctx.drawImage(this.image, 0, 0);

        // Apply glitch effect
        this.createGlitchEffect();

        // Continue animation
        requestAnimationFrame(() => this.animate());
      }
    }

    // Initialize glitch animation on page load
    document.addEventListener('DOMContentLoaded', () => {
      const glitchAnimation = new GlitchImageAnimation('images/kirupa.png', 'glitchCanvas');
    });
  </script>
</body>

</html>